友元分为两种：友元函数和友元类

在理解友元的时候可以不认为是朋友，而是理解为“上级，主人”，因为**friend后面跟的函数或者类都是可以访问自己这个类的私有成员**的。

**友元函数**

在定义一个类的时候，可以把一些函数（包括全局函数和其他类的成员函数）声明为“友元”，这样那些函数就成为该类的友元函数，在友元函数内部就能访问该类的私有成员了。

将全局函数声明为友元函数的写法如下:

friend 返回值类型 函数名(参数表);

将其他类的成员函数声明为友元的写法如下:

friend 返回值类型 其他类的类名::成员函数名(参数表);

**不能把其他类的私有成员函数声明为友元**

以全局函数为例，当一个全局函数想要访问一个对象的私有成员时，需要调用这个类的成员函数间接进行，如果想要直接访问的话，就需要在这个类中定义这个全局函数是自己的友元函数。

```cpp
#include <iostream>
using namespace std;

class CCar 
{
private:
	int price;
public:
	CCar(int price):price(price) { }
	friend int getCarPrice(CCar &car); // 把friend理解成father，后面跟的是fa，所以可以访问自己的东西
};

int getCarPrice(CCar &car)
{
	return car.price;
}

int main()
{
	CCar *car = new CCar(10);
	cout << getCarPrice(*car) << endl;
	return 0;
}
```

**友元类**

一个类A可以将另一个类B声明为自己的友元，类B的所有成员函数就都可以访问类A对象的私有成员。

其实就是把一个类的所有方法打包一块定义成友元了，和单独定义在使用上没有区别。

然后就是**友元关系在类直接不能传递**。就是朋友的朋友不一定是朋友。
